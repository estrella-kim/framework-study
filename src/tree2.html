<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="format-detection" content="telephone=no">
    <title>React</title>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
</head>

<body>
<script>
    (function() {

        var Stack = function (pSize) {
            var stack = [];
            var count = 0;
            var maxSize = pSize || 10;

            this.push = function (pData) {
                if (count < maxSize) {
                    stack[count++] = pData;

                    return {
                        data: pData,
                        msg: "success"
                    };
                } else {
                    return {
                        data: null,
                        msg: "스택 만땅"
                    };
                }
            };

            this.pop = function () {
                if (count > 0) {
                    return {
                        data: stack[--count],
                        msg: "success"
                    };
                } else {
                    return {
                        data: null,
                        msg: "스택 비었음"
                    };
                }
            };

            this.clear = function () {
                stack = [];
                count = 0;
            };
        };
        var Queue = function (pSize) {
            var queue = [];
            var count = 0;
            var front = 0;
            var rear = 0;
            var maxSize = pSize || 10;

            this.print =function() {
                console.log(front, rear, count);
                console.log(queue);
            };

            this.push = function (pData) {
                if (count < maxSize) {
                    queue[rear++] = pData;
                    rear = rear % maxSize;
                    ++count;

                    return {
                        data: pData,
                        msg: "success"
                    };
                } else {
                    return {
                        data: null,
                        msg: "큐가 꽉 찼음"
                    };
                }
            };

            this.pop = function () {
                if (count > 0) {
                    --count;

                    var data  = {
                        data: queue[front++],
                        msg: "success"
                    };

                    front = front % maxSize;

                    return data;
                } else {
                    return {
                        data: null,
                        msg: "큐가 비었음"
                    };
                }
            };

            this.clear = function () {
                queue = [];
                count = 0;
                front = 0;
                rear = 0;
            };
        }
        window.Stack = Stack;
        window.Queue = Queue;
    })();

    (function () {
        var BinaryTree = (function() {
            var binaryTree = function() {
                var root;

                this.getRoot = function() {
                    return root;
                };

                this.add=function(pNewNode, pType, pParentNode) {
                    if(pNewNode) {
                        if(pParentNode) {
                            pParentNode[pType] = pNewNode;
                            pNewNode.parent = pParentNode;
                        } else {
                            root = pNewNode;
                            pNewNode.parent=undefined;
                        }
                    } else {
                        pNewNode = undefined;
                    }

                    return pNewNode;
                };

                this.findWidth=function(pData) {
                    var q = new Queue(1000);

                    q.push(root);
                    var c = q.pop().data;

                    while(c) {
                        console.log(c.data, pData);
                        if(c.data===pData) {
                            return c;
                        } else {
                            if(c.left) {
                                q.push(c.left);
                            }

                            if(c.right) {
                                q.push(c.right);
                            }
                        }

                        c = q.pop().data;
                    }

                    return undefined;
                };

                this.findDepth=function(pData) {
                    var q = new Stack(1000);

                    q.push(root);
                    var c = q.pop().data;

                    while(c) {

                        if(c.data===pData) {
                            return c;
                        } else {
                            if(c.right) {
                                q.push(c.right);
                            }

                            if(c.left) {
                                q.push(c.left);
                            }
                        }

                        c = q.pop().data;
                    }

                    return undefined;
                };

                this.remove = function(pData) {
                    var pNode = this.findDepth(pData);
                    var current = pNode;

                    if(pNode) {
                        while(current.left !== undefined || current.right !== undefined) {

                            if(current.left) {
                                current.data = current['left'].data;
                                current = current['left'];
                            }else if(current.right) {
                                current.data = current['right'].data;
                                current = current['right'];
                            }
                        }
                        if(root === current) {
                            root = undefined;
                            return current;
                         }
                        if(current.parent.left && (current.parent.left.data === current.data) ){
                            current.parent.left = undefined;
                        }
                        if(current.parent.right && (current.parent.right.data === current.data) ){
                            current.parent.right = undefined;
                        }
                        return pNode;
                    }else {
                        return undefined;
                    }
                }
            };

            var binaryTreeNode = function(pData) {
                this.parent = undefined;
                this.left = undefined;
                this.right = undefined;
                this.data = pData;
            }

            binaryTree.Node = binaryTreeNode;

            return binaryTree;
        })();

        window.BinaryTree = BinaryTree;

        var t = new BinaryTree();
        var c = t.add(new BinaryTree.Node(1));
        var l, r;

        l = t.add(new BinaryTree.Node(3), "left", c);
        r = t.add(new BinaryTree.Node(6), "right", c);

        c=l;
        t.add(new BinaryTree.Node(2), "left", c);
        t.add(new BinaryTree.Node(4), "right", c);

        c=r;
        t.add(new BinaryTree.Node(5), "left", c);
        t.add(new BinaryTree.Node(7), "right", c);

        window.t = t;
    })();
</script>
</body>

</html>