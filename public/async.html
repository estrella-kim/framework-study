<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="format-detection" content="telephone=no">
    <title>React</title>
    <script src="https://code.jquery.com/jquery-1.12.4.min.js"></script>
</head>

<body>
<script>
        (function () {
            // 동기/비동기를 제어할 수 있는 클래스를 만든다.
            class Sync {
                constructor() {
                    this._asyncCount = 0;
                    this._next = [];
                }

                add(pFunc) {
                    this._next.push(pFunc);
                };

                next(pAsyncFlag) { // 조건을 탐색해서 함수를 꺼내 실행해주는 함수
                    if (!pAsyncFlag && this._asyncCount > 0) { //만약 리턴값이 트루지만 동시에 해야하는 작업이 실행되었다면 개수를 줄인다.
                        --this._asyncCount;
                    } else if (pAsyncFlag || (!pAsyncFlag && this._asyncCount === 0)) { // 만약 리턴값이 트루고 다음 실행작업이 없을 때는
                        if (this._next.length) {  // 실행작업들이 있을 때
                            var async = this._next.shift()();

                            if (async) { // return 값이 트루라면 다음 동시진행할 작업을 실행하고, 진행할 작업개수가 하나 늘어난다. async count는 0 일 때 동기적으로 다음 단위의 작업을 처리해주는 역할 .
                                ++this._asyncCount;
                                this.next(true);
                            }
                        }
                    }
                }
            }

            const syncNext = new Sync(); //한 상수가 클래스를 상속받아 클래스 안의 속성을 사용할 수 있게 된다.

            syncNext.add(function () {
                setTimeout(function () { // 언제 실행이 될 지 모를 때 기다리지 않고 다른 작업을 수행하게 만드는 비동기 테스트를 위해 setTImeout으로 브라우저에게 위임한다.
                    console.log("1", syncNext._asyncCount);
                    syncNext.next();
                }, 1000);

                return true;
            });

            syncNext.add(function () {
                setTimeout(function () {
                    console.log("2", syncNext._asyncCount);
                    syncNext.next();
                }, 1000);

                return true;
            });

            syncNext.add(function () {
                setTimeout(function () {
                    console.log("3", syncNext._asyncCount);
                    syncNext.next();
                }, 1000);
            });  // return 값이 true가 아니면 다음 작업단위는 동기적으로 실행이 된다.

            syncNext.add(function () {
                setTimeout(function () {
                    console.log("내가 먼저", syncNext._asyncCount);

                    const childSync = new Sync(); //새로운 상수가 클래스를 상속받아 클래스 안의 속성을 사용할 수 있게 된다.

                    childSync.add(function () {
                        setTimeout(function () { // 내 자식이 먼저
                            console.log("내 자식이 먼저", syncNext._asyncCount);

                            var grandChidSync = new Sync();
                            grandChidSync.add(function () {
                                setTimeout(function () {
                                    console.log("내 손자가 먼저", syncNext._asyncCount);
                                    syncNext.next();

                                }, 1000);
                                return true; // 다음 실행될 함수와 동시에 실행된다.
                            });

                            grandChidSync.next();

                        }, 1000);

                        return true;
                    });

                    childSync.add(function () {
                        setTimeout(function () {
                            console.log("내 자식의 두번째", syncNext._asyncCount);
                            syncNext.next();
                        }, 1000);

                    });

                    childSync.next();

                }, 1000);

                return true;
            });

            syncNext.add(function () {
                setTimeout(function () {
                    console.log("나는 나중", syncNext._asyncCount);

                    const childSync = new Sync();

                    childSync.add(function () {
                        setTimeout(function () { // 내 자식이 먼저
                            console.log("나중 자식이 먼저", syncNext._asyncCount);

                            const grandChidSync = new Sync();

                            grandChidSync.add(function () {
                                setTimeout(function () {
                                    console.log("나중 손자가 먼저", syncNext._asyncCount);
                                    syncNext.next();

                                }, 1000);
                                return true; // 다음 실행될 함수와 동시에 실행된다.
                            });

                            grandChidSync.next();

                        }, 1000);

                        return true;
                    });

                    childSync.add(function () {
                        setTimeout(function () { // 내 자식이 먼저
                            console.log("나중 자식이 두번째", syncNext._asyncCount);
                        }, 1000);
                    });

                    childSync.next();
                }, 900); // 언제 실행될지 모르니 time parameter는 랜덤하다.
            });

            syncNext.add(function () {
                setTimeout(function () {
                    console.log("나는 끝", syncNext._asyncCount);
                    syncNext.next();
                }, 300);
            });

            syncNext.next();
        })();
</script>
</body>

</html>